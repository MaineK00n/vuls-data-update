package trickest

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/fs"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/cheggaaa/pb/v3"
	"github.com/pkg/errors"

	"github.com/MaineK00n/vuls-data-update/pkg/fetch/util"
)

const defaultRepoURL = "https://github.com/trickest/cve.git"

type options struct {
	repoURL string
	dir     string
	retry   int
}

type Option interface {
	apply(*options)
}

type repoURLOption string

func (u repoURLOption) apply(opts *options) {
	opts.repoURL = string(u)
}

func WithRepoURL(repoURL string) Option {
	return repoURLOption(repoURL)
}

type dirOption string

func (d dirOption) apply(opts *options) {
	opts.dir = string(d)
}

func WithDir(dir string) Option {
	return dirOption(dir)
}

type retryOption int

func (r retryOption) apply(opts *options) {
	opts.retry = int(r)
}

func WithRetry(retry int) Option {
	return retryOption(retry)
}

func Fetch(opts ...Option) error {
	options := &options{
		repoURL: defaultRepoURL,
		dir:     filepath.Join(util.SourceDir(), "exploit", "trickest"),
		retry:   3,
	}

	for _, o := range opts {
		o.apply(options)
	}

	cloneDir := filepath.Join(util.CacheDir(), "trickest")
	if err := os.RemoveAll(cloneDir); err != nil {
		return errors.Wrapf(err, "remove %s", cloneDir)
	}
	if err := os.MkdirAll(cloneDir, os.ModePerm); err != nil {
		return errors.Wrapf(err, "mkdir %s", cloneDir)
	}

	if err := exec.Command("git", "clone", "--depth", "1", options.repoURL, cloneDir).Run(); err != nil {
		return errors.Wrapf(err, "git clone --depth 1 %s %s", options.repoURL, cloneDir)
	}

	var es []Exploit
	if err := filepath.WalkDir(cloneDir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			return nil
		}

		file := filepath.Base(path)
		if !strings.HasPrefix(file, "CVE-") {
			return nil
		}

		f, err := os.Open(path)
		if err != nil {
			return errors.Wrapf(err, "open %s", path)
		}
		defer f.Close()

		var (
			e       Exploit
			section string
		)
		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			t := scanner.Text()
			switch {
			case strings.HasPrefix(t, "### [CVE-"):
				section = "cve"
				cve, _, found := strings.Cut(strings.TrimPrefix(t, "### ["), "]")
				if !found {
					return errors.Errorf(`unexpected CVE line. expected: "### [CVE-xxxx-xxxx](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-xxxx-xxxx)", actual: "%s"`, t)
				}
				e.ID = cve
			case strings.HasPrefix(t, "### Description"):
				section = "description"
			case strings.HasPrefix(t, "### POC"):
			case strings.HasPrefix(t, "#### Reference"):
				section = "poc-reference"
			case strings.HasPrefix(t, "#### Github"):
				section = "poc-github"
			default:
				if t == "" {
					break
				}
				switch section {
				case "cve":
					u, err := url.Parse(strings.TrimSuffix(strings.TrimPrefix(t, "![]("), ")"))
					if err != nil {
						return errors.Wrapf(err, `unexpected badge line. expected: "![](https://img.shields.io/static/v1?label=<label>&message=<message>&color=<color>)", actual: "%s"`, t)
					}
					e.Tags = append(e.Tags, Tag{
						Label:   u.Query().Get("label"),
						Message: u.Query().Get("message"),
					})
				case "description":
					e.Description = fmt.Sprintf("%s %s", e.Description, strings.TrimSpace(t))
				case "poc-reference":
					if !strings.HasPrefix(t, "- ") {
						break
					}
					u, err := url.Parse(strings.TrimPrefix(t, "- "))
					if err != nil {
						return errors.Wrapf(err, `unexpected PoC Reference line. expected: "- <PoC URL>", actual: "%s"`, t)
					}
					e.Poc.References = append(e.Poc.References, u.String())
				case "poc-github":
					if !strings.HasPrefix(t, "- ") {
						break
					}
					u, err := url.Parse(strings.TrimPrefix(t, "- "))
					if err != nil {
						return errors.Wrapf(err, `unexpected PoC GitHub line. expected: "- <PoC URL>", actual: "%s"`, t)
					}
					e.Poc.GitHubs = append(e.Poc.GitHubs, u.String())
				}
			}
		}

		es = append(es, e)

		return nil
	}); err != nil {
		return err
	}

	if err := os.RemoveAll(options.dir); err != nil {
		return errors.Wrapf(err, "remove %s", options.dir)
	}

	bar := pb.StartNew(len(es))
	for _, e := range es {
		if err := func() error {
			y := strings.Split(e.ID, "-")[1]

			if err := os.MkdirAll(filepath.Join(options.dir, y), os.ModePerm); err != nil {
				return errors.Wrapf(err, "mkdir %s", filepath.Join(options.dir, y))
			}

			f, err := os.Create(filepath.Join(options.dir, y, fmt.Sprintf("%s.json", e.ID)))
			if err != nil {
				return errors.Wrapf(err, "create %s", filepath.Join(options.dir, y, fmt.Sprintf("%s.json", e.ID)))
			}
			defer f.Close()

			enc := json.NewEncoder(f)
			enc.SetIndent("", "  ")
			if err := enc.Encode(e); err != nil {
				return errors.Wrap(err, "encode data")
			}
			return nil
		}(); err != nil {
			return err
		}

		bar.Increment()
	}
	bar.Finish()

	if err := os.RemoveAll(cloneDir); err != nil {
		return errors.Wrapf(err, "remove %s", cloneDir)
	}

	return nil
}
