package exploitdb

import (
	"bytes"
	"encoding/csv"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"log"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/cheggaaa/pb/v3"
	"github.com/pkg/errors"
	"golang.org/x/exp/maps"
	"golang.org/x/net/html/charset"

	"github.com/MaineK00n/vuls-data-update/pkg/fetch/util"
)

var exploitdbURL = ExploitDBURL{
	Base:       "https://cve.mitre.org/data/downloads/allitems-cvrf.xml",
	Exploits:   "https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_exploits.csv",
	Shellcodes: "https://raw.githubusercontent.com/offensive-security/exploitdb/master/files_shellcodes.csv",
	Papers:     "https://raw.githubusercontent.com/offensive-security/exploitdb-papers/master/files_papers.csv",
}

type options struct {
	exploitdbURL *ExploitDBURL
	dir          string
	retry        int
}

type Option interface {
	apply(*options)
}

type exploitdbURLOption struct {
	ExploitDBURL *ExploitDBURL
}

func (u exploitdbURLOption) apply(opts *options) {
	opts.exploitdbURL = u.ExploitDBURL
}

func WithExploitDBURL(url *ExploitDBURL) Option {
	return exploitdbURLOption{ExploitDBURL: url}
}

type dirOption string

func (d dirOption) apply(opts *options) {
	opts.dir = string(d)
}

func WithDir(dir string) Option {
	return dirOption(dir)
}

type retryOption int

func (r retryOption) apply(opts *options) {
	opts.retry = int(r)
}

func WithRetry(retry int) Option {
	return retryOption(retry)
}

func Fetch(opts ...Option) error {
	options := &options{
		exploitdbURL: &exploitdbURL,
		dir:          filepath.Join(util.SourceDir(), "exploit", "exploitdb"),
		retry:        3,
	}

	for _, o := range opts {
		o.apply(options)
	}

	edbcve, err := options.fetchMitreCVRF()
	if err != nil {
		return errors.Wrap(err, "fetch mitre cvrf")
	}

	log.Println(`[INFO] Exploits`)
	eidToExploit, err := options.fetchExploits()
	if err != nil {
		return errors.Wrap(err, "fetch exploits")
	}
	for eid, cves := range edbcve.Exploits {
		e, ok := eidToExploit[eid]
		if !ok {
			e = Exploit{ID: eid}
		}
		e.CVEs = cves
		eidToExploit[eid] = e
	}

	dir := filepath.Join(options.dir, "exploits")
	if err := os.RemoveAll(dir); err != nil {
		return errors.Wrapf(err, "remove %s", dir)
	}
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return errors.Wrapf(err, "mkdir %s", dir)
	}
	bar := pb.StartNew(len(eidToExploit))
	for _, e := range maps.Values(eidToExploit) {
		if err := func() error {
			f, err := os.Create(filepath.Join(dir, fmt.Sprintf("%s.json", e.ID)))
			if err != nil {
				return errors.Wrapf(err, "create %s", filepath.Join(dir, fmt.Sprintf("%s.json", e.ID)))
			}
			defer f.Close()

			enc := json.NewEncoder(f)
			enc.SetIndent("", "  ")
			if err := enc.Encode(e); err != nil {
				return errors.Wrap(err, "encode data")
			}
			return nil
		}(); err != nil {
			return err
		}

		bar.Increment()
	}
	bar.Finish()

	log.Println(`[INFO] Shellcodes`)
	eidToShellcode, err := options.fetchShellcodes()
	if err != nil {
		return errors.Wrap(err, "fetch shellcodes")
	}
	for eid, cves := range edbcve.Shellcodes {
		e, ok := eidToShellcode[eid]
		if !ok {
			e = Shellcode{ID: eid}
		}
		e.CVEs = cves
		eidToShellcode[eid] = e
	}

	dir = filepath.Join(options.dir, "shellcodes")
	if err := os.RemoveAll(dir); err != nil {
		return errors.Wrapf(err, "remove %s", dir)
	}
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return errors.Wrapf(err, "mkdir %s", dir)
	}
	bar = pb.StartNew(len(eidToShellcode))
	for _, e := range eidToShellcode {
		if err := func() error {
			f, err := os.Create(filepath.Join(dir, fmt.Sprintf("%s.json", e.ID)))
			if err != nil {
				return errors.Wrapf(err, "create %s", filepath.Join(dir, fmt.Sprintf("%s.json", e.ID)))
			}
			defer f.Close()

			enc := json.NewEncoder(f)
			enc.SetIndent("", "  ")
			if err := enc.Encode(e); err != nil {
				return errors.Wrap(err, "encode data")
			}
			return nil
		}(); err != nil {
			return err
		}

		bar.Increment()
	}
	bar.Finish()

	log.Println(`[INFO] Papers`)
	eidToPaper, err := options.fetchPapers()
	if err != nil {
		return errors.Wrap(err, "fetch papers")
	}
	for eid, cves := range edbcve.Papers {
		e, ok := eidToPaper[eid]
		if !ok {
			e = Paper{ID: eid}
		}
		e.CVEs = cves
		eidToPaper[eid] = e
	}

	dir = filepath.Join(options.dir, "papers")
	if err := os.RemoveAll(dir); err != nil {
		return errors.Wrapf(err, "remove %s", dir)
	}
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return errors.Wrapf(err, "mkdir %s", dir)
	}
	bar = pb.StartNew(len(eidToPaper))
	for _, e := range eidToPaper {
		if err := func() error {
			f, err := os.Create(filepath.Join(dir, fmt.Sprintf("%s.json", e.ID)))
			if err != nil {
				return errors.Wrapf(err, "create %s", filepath.Join(dir, fmt.Sprintf("%s.json", e.ID)))
			}
			defer f.Close()

			enc := json.NewEncoder(f)
			enc.SetIndent("", "  ")
			if err := enc.Encode(e); err != nil {
				return errors.Wrap(err, "encode data")
			}
			return nil
		}(); err != nil {
			return err
		}

		bar.Increment()
	}
	bar.Finish()

	log.Println(`[INFO] GHDB`)
	ghdbs := make([]GHDB, 0, len(edbcve.GHDB))
	for eid, cves := range edbcve.GHDB {
		ghdbs = append(ghdbs, GHDB{
			ID:   eid,
			CVEs: cves,
		})
	}
	dir = filepath.Join(options.dir, "ghdb")
	if err := os.RemoveAll(dir); err != nil {
		return errors.Wrapf(err, "remove %s", dir)
	}
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return errors.Wrapf(err, "mkdir %s", dir)
	}
	bar = pb.StartNew(len(ghdbs))
	for _, e := range ghdbs {
		if err := func() error {
			f, err := os.Create(filepath.Join(dir, fmt.Sprintf("%s.json", e.ID)))
			if err != nil {
				return errors.Wrapf(err, "create %s", filepath.Join(dir, fmt.Sprintf("%s.json", e.ID)))
			}
			defer f.Close()

			enc := json.NewEncoder(f)
			enc.SetIndent("", "  ")
			if err := enc.Encode(e); err != nil {
				return errors.Wrap(err, "encode data")
			}
			return nil
		}(); err != nil {
			return err
		}

		bar.Increment()
	}
	bar.Finish()

	log.Println(`[INFO] Uncategorized`)
	uncategorizeds := make([]Uncategorized, 0, len(edbcve.Uncategorized))
	for eid, cves := range edbcve.Uncategorized {
		uncategorizeds = append(uncategorizeds, Uncategorized{
			ID:   eid,
			CVEs: cves,
		})
	}
	dir = filepath.Join(options.dir, "uncategorized")
	if err := os.RemoveAll(dir); err != nil {
		return errors.Wrapf(err, "remove %s", dir)
	}
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return errors.Wrapf(err, "mkdir %s", dir)
	}
	bar = pb.StartNew(len(uncategorizeds))
	for _, e := range uncategorizeds {
		if err := func() error {
			f, err := os.Create(filepath.Join(dir, fmt.Sprintf("%s.json", e.ID)))
			if err != nil {
				return errors.Wrapf(err, "create %s", filepath.Join(dir, fmt.Sprintf("%s.json", e.ID)))
			}
			defer f.Close()

			enc := json.NewEncoder(f)
			enc.SetIndent("", "  ")
			if err := enc.Encode(e); err != nil {
				return errors.Wrap(err, "encode data")
			}
			return nil
		}(); err != nil {
			return err
		}

		bar.Increment()
	}
	bar.Finish()

	return nil
}

func (opts options) fetchMitreCVRF() (edbcve, error) {
	bs, err := util.FetchURL(opts.exploitdbURL.Base, opts.retry)
	if err != nil {
		return edbcve{}, errors.Wrap(err, "fetch mitre cvrf data")
	}

	var doc cvrfdoc
	d := xml.NewDecoder(bytes.NewReader(bs))
	d.CharsetReader = charset.NewReaderLabel
	if err := d.Decode(&doc); err != nil {
		return edbcve{}, errors.Wrap(err, "decode xml")
	}

	m := edbcve{
		Exploits:      map[string][]string{},
		Shellcodes:    map[string][]string{},
		Papers:        map[string][]string{},
		GHDB:          map[string][]string{},
		Uncategorized: map[string][]UncategorizedCVE{},
	}
	for _, v := range doc.Vulnerability {
		for _, r := range v.References {
			source, name, found := strings.Cut(r.Description, ":")
			if source != "EXPLOIT-DB" || !found {
				continue
			}
			if r.URL == "" {
				if _, err := strconv.Atoi(name); err != nil {
					log.Printf(`[WARN] unexpected r.Description format. expected: "EXPLOIT-DB:<EDB-ID>", actual: "%s"`, r.Description)
					continue
				}
				m.Uncategorized[name] = append(m.Uncategorized[name], v.CVE)
				continue
			}

			u, err := url.Parse(r.URL)
			if err != nil {
				log.Printf(`[WARN] url.Parse(%s) = %s`, r.URL, err)
				continue
			}
			switch u.Host {
			case "www.exploit-db.com", "exploit-db.com":
				switch {
				case strings.HasPrefix(u.Path, "/exploits"):
					eid := strings.TrimSuffix(strings.TrimPrefix(u.Path, "/exploits/"), "/")
					m.Exploits[eid] = append(m.Exploits[eid], v.CVE)
				case strings.HasPrefix(u.Path, "/shellcodes"):
					eid := strings.TrimSuffix(strings.TrimPrefix(u.Path, "/shellcodes/"), "/")
					m.Shellcodes[eid] = append(m.Shellcodes[eid], v.CVE)
				case strings.HasPrefix(u.Path, "/papers"):
					eid := strings.TrimSuffix(strings.TrimPrefix(u.Path, "/papers/"), "/")
					m.Papers[eid] = append(m.Papers[eid], v.CVE)
				case strings.HasPrefix(u.Path, "/ghdb"):
					eid := strings.TrimSuffix(strings.TrimPrefix(u.Path, "/ghdb/"), "/")
					m.GHDB[eid] = append(m.GHDB[eid], v.CVE)
				case strings.HasPrefix(u.Path, "/docs"):
					eid := strings.TrimSuffix(strings.TrimPrefix(u.Path, "/docs/"), "/")
					m.Uncategorized[eid] = append(m.Uncategorized[eid], UncategorizedCVE{
						CVE: v.CVE,
						URL: r.URL,
					})
				case strings.HasPrefix(u.Path, "/download"):
					eid := strings.TrimSuffix(strings.TrimPrefix(u.Path, "/download/"), "/")
					m.Uncategorized[eid] = append(m.Uncategorized[eid], UncategorizedCVE{
						CVE: v.CVE,
						URL: r.URL,
					})
				}
			}
		}
	}
	return m, nil
}

func (opts options) fetchExploits() (map[string]Exploit, error) {
	bs, err := util.FetchURL(opts.exploitdbURL.Exploits, opts.retry)
	if err != nil {
		return nil, errors.Wrap(err, "fetch exploits data")
	}

	records, err := csv.NewReader(bytes.NewReader(bs)).ReadAll()
	if err != nil {
		return nil, errors.Wrap(err, "read csv")
	}

	parseDateFn := func(v string) *time.Time {
		if v == "" {
			return nil
		}
		if t, err := time.Parse("2006-01-02", v); err == nil {
			return &t
		}
		log.Printf(`[WARN] error time.Parse date="%s"`, v)
		return nil
	}

	parsePortFn := func(v string) *int {
		if v == "" {
			return nil
		}
		if i, err := strconv.Atoi(v); err == nil {
			return &i
		}
		log.Printf(`[WARN] error strconv.Atoi s="%s"`, v)
		return nil
	}

	m := map[string]Exploit{}
	for _, r := range records[1:] {
		if len(r) != 8 {
			log.Printf(`[WARN] unexpected exploit line. expected: "id,file,description,date,author,type,platform,port", actual: "%s"`, strings.Join(r, ","))
			continue
		}
		m[r[0]] = Exploit{
			ID:          r[0],
			File:        r[1],
			Description: r[2],
			Date:        parseDateFn(r[3]),
			Author:      r[4],
			Type:        r[5],
			Platform:    r[6],
			Port:        parsePortFn(r[7]),
		}
	}
	return m, nil
}

func (opts options) fetchShellcodes() (map[string]Shellcode, error) {
	bs, err := util.FetchURL(opts.exploitdbURL.Shellcodes, opts.retry)
	if err != nil {
		return nil, errors.Wrap(err, "fetch shellcodes data")
	}

	records, err := csv.NewReader(bytes.NewReader(bs)).ReadAll()
	if err != nil {
		return nil, errors.Wrap(err, "read csv")
	}

	parseDateFn := func(v string) *time.Time {
		if v == "" {
			return nil
		}
		if t, err := time.Parse("2006-01-02", v); err == nil {
			return &t
		}
		log.Printf(`[WARN] error time.Parse date="%s"`, v)
		return nil
	}

	m := map[string]Shellcode{}
	for _, r := range records[1:] {
		if len(r) != 7 {
			log.Printf(`[WARN] unexpected shellcode line. expected: "id,file,description,date,author,type,platform", actual: "%s"`, strings.Join(r, ","))
			continue
		}
		m[r[0]] = Shellcode{
			ID:          r[0],
			File:        r[1],
			Description: r[2],
			Date:        parseDateFn(r[3]),
			Author:      r[4],
			Type:        r[5],
			Platform:    r[6],
		}
	}
	return m, nil
}

func (opts options) fetchPapers() (map[string]Paper, error) {
	bs, err := util.FetchURL(opts.exploitdbURL.Papers, opts.retry)
	if err != nil {
		return nil, errors.Wrap(err, "fetch papers data")
	}

	records, err := csv.NewReader(bytes.NewReader(bs)).ReadAll()
	if err != nil {
		return nil, errors.Wrap(err, "read csv")
	}

	parseDateFn := func(v string) *time.Time {
		if v == "" {
			return nil
		}
		if t, err := time.Parse("2006-01-02", v); err == nil {
			return &t
		}
		log.Printf(`[WARN] error time.Parse date="%s"`, v)
		return nil
	}

	m := map[string]Paper{}
	for _, r := range records[1:] {
		if len(r) != 8 {
			log.Printf(`[WARN] unexpected paper line. expected: "id,file,description,date,author,type,platform,language", actual: "%s"`, strings.Join(r, ","))
			continue
		}
		m[r[0]] = Paper{
			ID:          r[0],
			File:        r[1],
			Description: r[2],
			Date:        parseDateFn(r[3]),
			Author:      r[4],
			Type:        r[5],
			Platform:    r[6],
			Language:    r[7],
		}
	}
	return m, nil
}
