package trickest

import (
	"archive/tar"
	"bufio"
	"compress/gzip"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"path/filepath"
	"strings"
	"time"

	"github.com/cheggaaa/pb/v3"
	"github.com/pkg/errors"

	"github.com/MaineK00n/vuls-data-update/pkg/fetch/util"
	utilhttp "github.com/MaineK00n/vuls-data-update/pkg/fetch/util/http"
)

const defaultRepoURL = "https://github.com/trickest/cve/archive/refs/heads/main.tar.gz"

type options struct {
	repoURL string
	dir     string
	retry   int
}

type Option interface {
	apply(*options)
}

type repoURLOption string

func (u repoURLOption) apply(opts *options) {
	opts.repoURL = string(u)
}

func WithRepoURL(repoURL string) Option {
	return repoURLOption(repoURL)
}

type dirOption string

func (d dirOption) apply(opts *options) {
	opts.dir = string(d)
}

func WithDir(dir string) Option {
	return dirOption(dir)
}

type retryOption int

func (r retryOption) apply(opts *options) {
	opts.retry = int(r)
}

func WithRetry(retry int) Option {
	return retryOption(retry)
}

func Fetch(opts ...Option) error {
	options := &options{
		repoURL: defaultRepoURL,
		dir:     filepath.Join(util.CacheDir(), "fetch", "exploit", "trickest"),
		retry:   3,
	}

	for _, o := range opts {
		o.apply(options)
	}

	if err := util.RemoveAll(options.dir); err != nil {
		return errors.Wrapf(err, "remove %s", options.dir)
	}

	log.Println("[INFO] Fetch trickest")
	var es []Exploit

	resp, err := utilhttp.NewClient(utilhttp.WithClientRetryMax(options.retry)).Get(options.repoURL)
	if err != nil {
		return errors.Wrap(err, "fetch repository")
	}
	defer resp.Body.Close() //nolint:errcheck

	if resp.StatusCode != http.StatusOK {
		_, _ = io.Copy(io.Discard, resp.Body)
		return errors.Errorf("error response with status code %d", resp.StatusCode)
	}

	gr, err := gzip.NewReader(resp.Body)
	if err != nil {
		return errors.Wrap(err, "create gzip reader")
	}
	defer gr.Close() //nolint:errcheck

	tr := tar.NewReader(gr)
	for {
		hdr, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return errors.Wrap(err, "next tar reader")
		}

		if hdr.FileInfo().IsDir() {
			continue
		}

		file := filepath.Base(hdr.Name)
		if !strings.HasPrefix(file, "CVE-") {
			continue
		}

		var (
			e       Exploit
			section string
		)
		scanner := bufio.NewScanner(tr)
		for scanner.Scan() {
			t := scanner.Text()
			switch {
			case strings.HasPrefix(t, "### [CVE-"):
				section = "cve"
				cve, _, found := strings.Cut(strings.TrimPrefix(t, "### ["), "]")
				if !found {
					return errors.Errorf(`unexpected CVE line. expected: "### [CVE-xxxx-xxxx](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-xxxx-xxxx)", actual: "%s"`, t)
				}
				e.ID = cve
			case strings.HasPrefix(t, "### Description"):
				section = "description"
			case strings.HasPrefix(t, "### POC"):
			case strings.HasPrefix(t, "#### Reference"):
				section = "poc-reference"
			case strings.HasPrefix(t, "#### Github"):
				section = "poc-github"
			default:
				if t == "" {
					break
				}
				switch section {
				case "cve":
					u, err := url.Parse(strings.TrimSuffix(strings.TrimPrefix(t, "![]("), ")"))
					if err != nil {
						return errors.Wrapf(err, `unexpected badge line. expected: "![](https://img.shields.io/static/v1?label=<label>&message=<message>&color=<color>)", actual: "%s"`, t)
					}
					e.Tags = append(e.Tags, Tag{
						Label:   u.Query().Get("label"),
						Message: u.Query().Get("message"),
					})
				case "description":
					e.Description = fmt.Sprintf("%s %s", e.Description, strings.TrimSpace(t))
				case "poc-reference":
					if !strings.HasPrefix(t, "- ") {
						break
					}
					u, err := url.Parse(strings.TrimPrefix(t, "- "))
					if err != nil {
						return errors.Wrapf(err, `unexpected PoC Reference line. expected: "- <PoC URL>", actual: "%s"`, t)
					}
					e.Poc.References = append(e.Poc.References, u.String())
				case "poc-github":
					if !strings.HasPrefix(t, "- ") {
						break
					}
					u, err := url.Parse(strings.TrimPrefix(t, "- "))
					if err != nil {
						return errors.Wrapf(err, `unexpected PoC GitHub line. expected: "- <PoC URL>", actual: "%s"`, t)
					}
					e.Poc.GitHubs = append(e.Poc.GitHubs, u.String())
				}
			}
		}
		if err := scanner.Err(); err != nil {
			return errors.Wrap(err, "scanner encounter error")
		}

		es = append(es, e)
	}

	bar := pb.StartNew(len(es))
	for _, e := range es {
		splitted, err := util.Split(e.ID, "-", "-")
		if err != nil {
			log.Printf("[WARN] unexpected ID format. expected: %q, actual: %q", "CVE-yyyy-\\d{4,}", e.ID)
			continue
		}
		if _, err := time.Parse("2006", splitted[1]); err != nil {
			log.Printf("[WARN] unexpected ID format. expected: %q, actual: %q", "CVE-yyyy-\\d{4,}", e.ID)
			continue
		}

		if err := util.Write(filepath.Join(options.dir, splitted[1], fmt.Sprintf("%s.json", e.ID)), e); err != nil {
			return errors.Wrapf(err, "write %s", filepath.Join(options.dir, splitted[1], fmt.Sprintf("%s.json", e.ID)))
		}

		bar.Increment()
	}
	bar.Finish()

	return nil
}
