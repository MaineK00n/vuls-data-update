package content

import (
	"cmp"
	"slices"
	"time"

	cweTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/cwe"
	epssTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/epss"
	exploitTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/exploit"
	kevTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/kev"
	metasploitTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/metasploit"
	referenceTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/reference"
	severityTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/severity"
	snortTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/snort"
)

type Content struct {
	ID          string                       `json:"id,omitempty"`
	Title       string                       `json:"title,omitempty"`
	Description string                       `json:"description,omitempty"`
	Severity    []severityTypes.Severity     `json:"severity,omitempty"`
	CWE         []cweTypes.CWE               `json:"cwe,omitempty"`
	Exploit     []exploitTypes.Exploit       `json:"exploit,omitempty"`
	Metasploit  []metasploitTypes.Metasploit `json:"metasploit,omitempty"`
	EPSS        *epssTypes.EPSS              `json:"epss,omitempty"`
	Snort       []snortTypes.Snort           `json:"snort,omitempty"`
	KEV         *kevTypes.KEV                `json:"kev,omitempty"`
	References  []referenceTypes.Reference   `json:"references,omitempty"`
	Published   *time.Time                   `json:"published,omitempty"`
	Modified    *time.Time                   `json:"modified,omitempty"`
	Optional    map[string]interface{}       `json:"optional,omitempty"`
}

func (c *Content) Sort() {
	slices.SortFunc(c.Severity, severityTypes.Compare)

	for i := range c.CWE {
		(&c.CWE[i]).Sort()
	}
	slices.SortFunc(c.CWE, cweTypes.Compare)

	slices.SortFunc(c.Exploit, exploitTypes.Compare)

	for i := range c.Metasploit {
		(&c.Metasploit[i]).Sort()
	}
	slices.SortFunc(c.Metasploit, metasploitTypes.Compare)

	slices.SortFunc(c.Snort, snortTypes.Compare)

	slices.SortFunc(c.References, referenceTypes.Compare)
}

func Compare(x, y Content) int {
	return cmp.Or(
		cmp.Compare(x.ID, y.ID),
		cmp.Compare(x.Title, y.Title),
		cmp.Compare(x.Description, y.Description),
		slices.CompareFunc(x.Severity, y.Severity, severityTypes.Compare),
		slices.CompareFunc(x.CWE, y.CWE, cweTypes.Compare),
		slices.CompareFunc(x.Exploit, y.Exploit, exploitTypes.Compare),
		slices.CompareFunc(x.Metasploit, y.Metasploit, metasploitTypes.Compare),
		func() int {
			switch {
			case x.EPSS == nil && y.EPSS == nil:
				return 0
			case x.EPSS == nil && y.EPSS != nil:
				return -1
			case x.EPSS != nil && y.EPSS == nil:
				return +1
			default:
				return epssTypes.Compare(*x.EPSS, *y.EPSS)
			}
		}(),
		slices.CompareFunc(x.Snort, y.Snort, snortTypes.Compare),
		func() int {
			switch {
			case x.KEV == nil && y.KEV == nil:
				return 0
			case x.KEV == nil && y.KEV != nil:
				return -1
			case x.KEV != nil && y.KEV == nil:
				return +1
			default:
				return kevTypes.Compare(*x.KEV, *y.KEV)
			}
		}(),
		slices.CompareFunc(x.References, y.References, referenceTypes.Compare),
		func() int {
			switch {
			case x.Published == nil && y.Published == nil:
				return 0
			case x.Published == nil && y.Published != nil:
				return -1
			case x.Published != nil && y.Published == nil:
				return +1
			default:
				return (*x.Published).Compare(*y.Published)
			}
		}(),
		func() int {
			switch {
			case x.Modified == nil && y.Modified == nil:
				return 0
			case x.Modified == nil && y.Modified != nil:
				return -1
			case x.Modified != nil && y.Modified == nil:
				return +1
			default:
				return (*x.Modified).Compare(*y.Modified)
			}
		}(),
	)
}
