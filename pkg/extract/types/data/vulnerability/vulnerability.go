package vulnerability

import (
	"cmp"
	"slices"
	"time"

	cweTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/cwe"
	epssTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/epss"
	exploitTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/exploit"
	metasploitTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/metasploit"
	referenceTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/reference"
	severityTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/severity"
	snortTypes "github.com/MaineK00n/vuls-data-update/pkg/extract/types/data/snort"
)

type Vulnerability struct {
	ID          string                       `json:"id,omitempty"`
	Title       string                       `json:"title,omitempty"`
	Description string                       `json:"description,omitempty"`
	Severity    []severityTypes.Severity     `json:"severity,omitempty"`
	CWE         []cweTypes.CWE               `json:"cwe,omitempty"`
	Exploit     []exploitTypes.Exploit       `json:"exploit,omitempty"`
	Metasploit  []metasploitTypes.Metasploit `json:"metasploit,omitempty"`
	EPSS        []epssTypes.EPSS             `json:"epss,omitempty"`
	Snort       []snortTypes.Snort           `json:"snort,omitempty"`
	References  []referenceTypes.Reference   `json:"references,omitempty"`
	Published   *time.Time                   `json:"published,omitempty"`
	Modified    *time.Time                   `json:"modified,omitempty"`
	Optional    map[string]interface{}       `json:"optional,omitempty"`
}

func (v *Vulnerability) Sort() {
	slices.SortFunc(v.Severity, severityTypes.Compare)

	for i := range v.CWE {
		(&v.CWE[i]).Sort()
	}
	slices.SortFunc(v.CWE, cweTypes.Compare)

	slices.SortFunc(v.Exploit, exploitTypes.Compare)

	for i := range v.Metasploit {
		(&v.Metasploit[i]).Sort()
	}
	slices.SortFunc(v.Metasploit, metasploitTypes.Compare)

	slices.SortFunc(v.EPSS, epssTypes.Compare)

	slices.SortFunc(v.Snort, snortTypes.Compare)

	slices.SortFunc(v.References, referenceTypes.Compare)
}

func Compare(x, y Vulnerability) int {
	return cmp.Or(
		cmp.Compare(x.ID, y.ID),
		cmp.Compare(x.Title, y.Title),
		cmp.Compare(x.Description, y.Description),
		slices.CompareFunc(x.Severity, y.Severity, severityTypes.Compare),
		slices.CompareFunc(x.CWE, y.CWE, cweTypes.Compare),
		slices.CompareFunc(x.Exploit, y.Exploit, exploitTypes.Compare),
		slices.CompareFunc(x.Metasploit, y.Metasploit, metasploitTypes.Compare),
		slices.CompareFunc(x.EPSS, y.EPSS, epssTypes.Compare),
		slices.CompareFunc(x.Snort, y.Snort, snortTypes.Compare),
		slices.CompareFunc(x.References, y.References, referenceTypes.Compare),
		func() int {
			switch {
			case x.Published == nil && y.Published == nil:
				return 0
			case x.Published == nil && y.Published != nil:
				return -1
			case x.Published != nil && y.Published == nil:
				return +1
			default:
				return (*x.Published).Compare(*y.Published)
			}
		}(),
		func() int {
			switch {
			case x.Modified == nil && y.Modified == nil:
				return 0
			case x.Modified == nil && y.Modified != nil:
				return -1
			case x.Modified != nil && y.Modified == nil:
				return +1
			default:
				return (*x.Modified).Compare(*y.Modified)
			}
		}(),
	)
}
